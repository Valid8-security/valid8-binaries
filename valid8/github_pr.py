"""
GitHub Auto-Fix PR Creation

Automatically creates pull requests with AI-generated fixes for detected vulnerabilities.
Supports:
- GitHub API integration
- Branch creation
- Commit generation
- PR creation with detailed descriptions
- Multi-file fixes
- CI/CD integration
"""

import os
import json
import requests
from typing import List, Dict, Any, Optional
from pathlib import Path
from dataclasses import dataclass
import subprocess
import tempfile
from datetime import datetime


@dataclass
class PRConfig:
    """Configuration for PR creation"""
    repo_owner: str
    repo_name: str
    base_branch: str = "main"
    github_token: Optional[str] = None
    pr_title_template: str = "üîí Security: Fix {count} vulnerability(ies)"
    pr_body_template: str = """## Security Fixes

This PR addresses {count} security vulnerability(ies) detected by Parry Security Scanner.

{details}

### Changes Made
{changes}

### Verification
- Parry security scan passed ‚úÖ
- All existing tests should pass
- No functional changes expected

**Generated by**: [Parry Security Scanner](https://github.com/parry/parry)
**Scan ID**: {scan_id}
"""


class GitHubAPI:
    """GitHub API client"""
    
    def __init__(self, token: Optional[str] = None):
        self.token = token or os.getenv('GITHUB_TOKEN')
        if not self.token:
            raise ValueError("GitHub token required. Set GITHUB_TOKEN environment variable or pass token parameter.")
        
        self.base_url = "https://api.github.com"
        self.headers = {
            "Authorization": f"token {self.token}",
            "Accept": "application/vnd.github.v3+json",
            "User-Agent": "Parry-Security-Scanner"
        }
    
    def _request(self, method: str, endpoint: str, data: Optional[Dict] = None) -> Dict:
        """Make API request"""
        url = f"{self.base_url}/{endpoint}"
        
        try:
            if method == "GET":
                response = requests.get(url, headers=self.headers)
            elif method == "POST":
                response = requests.post(url, headers=self.headers, json=data)
            elif method == "PATCH":
                response = requests.patch(url, headers=self.headers, json=data)
            elif method == "PUT":
                response = requests.put(url, headers=self.headers, json=data)
            else:
                raise ValueError(f"Unsupported method: {method}")
            
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            raise Exception(f"GitHub API error: {e}")
    
    def get_repo(self, owner: str, repo: str) -> Dict:
        """Get repository information"""
        return self._request("GET", f"repos/{owner}/{repo}")
    
    def get_branch(self, owner: str, repo: str, branch: str) -> Dict:
        """Get branch information"""
        return self._request("GET", f"repos/{owner}/{repo}/branches/{branch}")
    
    def create_branch(self, owner: str, repo: str, branch_name: str, from_sha: str) -> Dict:
        """Create a new branch"""
        data = {
            "ref": f"refs/heads/{branch_name}",
            "sha": from_sha
        }
        return self._request("POST", f"repos/{owner}/{repo}/git/refs", data)
    
    def get_file_content(self, owner: str, repo: str, path: str, ref: str = "main") -> Dict:
        """Get file content from repository"""
        return self._request("GET", f"repos/{owner}/{repo}/contents/{path}?ref={ref}")
    
    def update_file(self, owner: str, repo: str, path: str, content: str, message: str, sha: str, branch: str) -> Dict:
        """Update file in repository"""
        import base64
        
        data = {
            "message": message,
            "content": base64.b64encode(content.encode()).decode(),
            "sha": sha,
            "branch": branch
        }
        return self._request("PUT", f"repos/{owner}/{repo}/contents/{path}", data)
    
    def create_pull_request(self, owner: str, repo: str, title: str, body: str, head: str, base: str) -> Dict:
        """Create a pull request"""
        data = {
            "title": title,
            "body": body,
            "head": head,
            "base": base
        }
        return self._request("POST", f"repos/{owner}/{repo}/pulls", data)


class AutoFixPRCreator:
    """Automatically create PRs with security fixes"""
    
    def __init__(self, config: PRConfig):
        self.config = config
        self.github = GitHubAPI(config.github_token)
        self.scan_id = datetime.now().strftime("%Y%m%d_%H%M%S")
    
    def create_pr_for_fixes(self, fixes: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Create a pull request with all fixes
        
        Args:
            fixes: List of fix dictionaries with keys:
                - file_path: Path to file
                - original_code: Original vulnerable code
                - fixed_code: Fixed code
                - vulnerability: Vulnerability details
                - line_number: Line number of fix
        
        Returns:
            PR information including URL
        """
        if not fixes:
            return {"error": "No fixes provided"}
        
        # Create unique branch name
        branch_name = f"parry-security-fixes-{self.scan_id}"
        
        try:
            # Get base branch SHA
            base_branch_info = self.github.get_branch(
                self.config.repo_owner,
                self.config.repo_name,
                self.config.base_branch
            )
            base_sha = base_branch_info['commit']['sha']
            
            # Create new branch
            print(f"Creating branch: {branch_name}")
            self.github.create_branch(
                self.config.repo_owner,
                self.config.repo_name,
                branch_name,
                base_sha
            )
            
            # Apply each fix
            commit_messages = []
            for fix in fixes:
                file_path = fix['file_path']
                fixed_code = fix['fixed_code']
                vuln = fix.get('vulnerability', {})
                
                # Get current file content
                file_info = self.github.get_file_content(
                    self.config.repo_owner,
                    self.config.repo_name,
                    file_path,
                    ref=branch_name
                )
                
                # Update file
                commit_message = f"Fix {vuln.get('cwe', 'vulnerability')} in {file_path}"
                self.github.update_file(
                    self.config.repo_owner,
                    self.config.repo_name,
                    file_path,
                    fixed_code,
                    commit_message,
                    file_info['sha'],
                    branch_name
                )
                
                commit_messages.append(commit_message)
                print(f"‚úì Applied fix to {file_path}")
            
            # Create PR
            pr_title = self.config.pr_title_template.format(count=len(fixes))
            pr_body = self._generate_pr_body(fixes)
            
            print(f"Creating pull request...")
            pr = self.github.create_pull_request(
                self.config.repo_owner,
                self.config.repo_name,
                pr_title,
                pr_body,
                branch_name,
                self.config.base_branch
            )
            
            return {
                "success": True,
                "pr_url": pr['html_url'],
                "pr_number": pr['number'],
                "branch": branch_name,
                "fixes_applied": len(fixes),
                "commits": commit_messages
            }
            
        except Exception as e:
            return {
                "success": False,
                "error": str(e)
            }
    
    def _generate_pr_body(self, fixes: List[Dict[str, Any]]) -> str:
        """Generate PR body with fix details"""
        details_lines = []
        changes_lines = []
        
        for i, fix in enumerate(fixes, 1):
            vuln = fix.get('vulnerability', {})
            file_path = fix['file_path']
            line_num = fix.get('line_number', 'unknown')
            
            # Vulnerability details
            details_lines.append(f"### {i}. {vuln.get('title', 'Security Issue')}")
            details_lines.append(f"- **CWE**: {vuln.get('cwe', 'N/A')}")
            details_lines.append(f"- **Severity**: {vuln.get('severity', 'unknown').upper()}")
            details_lines.append(f"- **File**: `{file_path}:{line_num}`")
            details_lines.append(f"- **Description**: {vuln.get('description', 'N/A')}")
            details_lines.append("")
            
            # Changes
            changes_lines.append(f"#### {file_path}")
            changes_lines.append("```diff")
            changes_lines.append(f"- {fix.get('original_code', '').strip()}")
            changes_lines.append(f"+ {fix.get('fixed_code', '').strip()[:100]}...")
            changes_lines.append("```")
            changes_lines.append("")
        
        details = "\n".join(details_lines)
        changes = "\n".join(changes_lines)
        
        return self.config.pr_body_template.format(
            count=len(fixes),
            details=details,
            changes=changes,
            scan_id=self.scan_id
        )
    
    def create_pr_with_local_changes(self, repo_path: Path, fixes: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Create PR using local git operations (alternative to API)
        
        Useful when:
        - Working with local repository
        - Want to use git CLI
        - Need more control over commits
        """
        branch_name = f"parry-security-fixes-{self.scan_id}"
        
        try:
            # Change to repo directory
            original_dir = os.getcwd()
            os.chdir(repo_path)
            
            # Create and checkout new branch
            subprocess.run(['git', 'checkout', '-b', branch_name], check=True)
            
            # Apply fixes
            for fix in fixes:
                file_path = fix['file_path']
                fixed_code = fix['fixed_code']
                
                # Write fixed code
                full_path = repo_path / file_path
                full_path.write_text(fixed_code)
                
                # Stage file
                subprocess.run(['git', 'add', file_path], check=True)
            
            # Commit changes
            commit_message = f"üîí Security: Fix {len(fixes)} vulnerability(ies)\n\n"
            commit_message += "Fixes generated by Parry Security Scanner"
            subprocess.run(['git', 'commit', '-m', commit_message], check=True)
            
            # Push branch
            subprocess.run(['git', 'push', 'origin', branch_name], check=True)
            
            # Create PR via API
            pr_title = self.config.pr_title_template.format(count=len(fixes))
            pr_body = self._generate_pr_body(fixes)
            
            pr = self.github.create_pull_request(
                self.config.repo_owner,
                self.config.repo_name,
                pr_title,
                pr_body,
                branch_name,
                self.config.base_branch
            )
            
            # Return to original directory
            os.chdir(original_dir)
            
            return {
                "success": True,
                "pr_url": pr['html_url'],
                "pr_number": pr['number'],
                "branch": branch_name,
                "fixes_applied": len(fixes)
            }
            
        except subprocess.CalledProcessError as e:
            os.chdir(original_dir)
            return {
                "success": False,
                "error": f"Git operation failed: {e}"
            }
        except Exception as e:
            os.chdir(original_dir)
            return {
                "success": False,
                "error": str(e)
            }


def create_security_fix_pr(
    repo_owner: str,
    repo_name: str,
    fixes: List[Dict[str, Any]],
    github_token: Optional[str] = None,
    base_branch: str = "main"
) -> Dict[str, Any]:
    """
    Convenience function to create a security fix PR
    
    Args:
        repo_owner: GitHub repository owner
        repo_name: Repository name
        fixes: List of fixes to apply
        github_token: GitHub API token (or use GITHUB_TOKEN env var)
        base_branch: Base branch to create PR against
    
    Returns:
        PR creation result
    """
    config = PRConfig(
        repo_owner=repo_owner,
        repo_name=repo_name,
        base_branch=base_branch,
        github_token=github_token
    )
    
    creator = AutoFixPRCreator(config)
    return creator.create_pr_for_fixes(fixes)


# Example usage
if __name__ == "__main__":
    # Example: Create PR with security fixes
    example_fixes = [
        {
            "file_path": "src/auth.py",
            "original_code": 'password = "hardcoded123"',
            "fixed_code": 'password = os.getenv("PASSWORD")',
            "vulnerability": {
                "cwe": "CWE-798",
                "severity": "critical",
                "title": "Hardcoded Credentials",
                "description": "Password is hardcoded in source code"
            },
            "line_number": 42
        }
    ]
    
    result = create_security_fix_pr(
        repo_owner="your-org",
        repo_name="your-repo",
        fixes=example_fixes
    )
    
    if result.get("success"):
        print(f"‚úÖ PR created: {result['pr_url']}")
    else:
        print(f"‚ùå Error: {result.get('error')}")

