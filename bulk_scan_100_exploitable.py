#!/usr/bin/env python3
"""
Bulk Scan for 100 Distinct Exploitable Vulnerabilities
Focuses on user-input vulnerabilities in views, APIs, and form handlers
"""

import sys
import os
import json
import subprocess
import time
import re
from pathlib import Path
from typing import Dict, List, Tuple, Optional, Set
from collections import defaultdict

sys.path.insert(0, os.getcwd())

from valid8.scanner import Scanner

class ExploitableVulnerabilityScanner:
    """Scan for exploitable vulnerabilities with user input"""
    
    def __init__(self):
        self.scanner = Scanner()
        self.verified_vulnerabilities = []
        self.distinct_issues = set()  # Track distinct vulnerabilities
        self.scan_stats = {
            'codebases_scanned': 0,
            'total_findings': 0,
            'filtered_noise': 0,
            'verified_exploitable': 0,
            'distinct_issues': 0,
            'target': 100
        }
        self.scan_dir = Path("/tmp/valid8_bulk_scan")
        self.scan_dir.mkdir(exist_ok=True)
    
    def get_target_directories(self, repo_path: Path, repo_name: str) -> List[Path]:
        """Get directories most likely to have user-input vulnerabilities"""
        targets = []
        
        # Web frameworks - focus on user-facing code
        if repo_name == 'django':
            targets = [
                repo_path / 'django' / 'contrib' / 'admin',
                repo_path / 'django' / 'contrib' / 'auth',
                repo_path / 'django' / 'contrib' / 'sessions',
                repo_path / 'django' / 'core' / 'handlers',
                repo_path / 'django' / 'http',
                repo_path / 'django' / 'views',
            ]
        elif repo_name == 'flask':
            targets = [
                repo_path / 'src' / 'flask',
                repo_path / 'flask',
            ]
        elif repo_name == 'fastapi':
            targets = [
                repo_path / 'fastapi',
            ]
        elif repo_name == 'tornado':
            targets = [
                repo_path / 'tornado',
            ]
        elif repo_name in ['requests', 'httpx', 'aiohttp', 'urllib3']:
            # HTTP libraries - scan for SSRF, header injection, etc.
            targets = [repo_path]
        elif repo_name in ['sqlalchemy', 'peewee', 'tortoise-orm']:
            # ORMs - scan for SQL injection in query building
            targets = [repo_path]
        elif 'auth' in repo_name.lower() or 'oauth' in repo_name.lower():
            # Auth libraries - scan for auth bypass, token issues
            targets = [repo_path]
        elif 'template' in repo_name.lower() or 'jinja' in repo_name.lower():
            # Template engines - scan for template injection
            targets = [repo_path]
        else:
            # Default: scan entire repo
            targets = [repo_path]
        
        # Filter to existing directories
        return [t for t in targets if t.exists()]
    
    def is_user_input_vulnerability(self, finding: Dict, code_context: str) -> Tuple[bool, str]:
        """Check if vulnerability involves user input"""
        file_path = finding.get('file_path', '')
        cwe = finding.get('cwe', '')
        line_num = finding.get('line_number', 0)
        
        # Filter out Rust/C files
        if file_path.endswith(('.rs', '.c', '.h', '.cpp', '.cc')):
            return False, "Wrong language (Rust/C code)"
        
        # Read actual code
        try:
            fp = Path(file_path)
            if not fp.exists():
                return False, "File not found"
            
            with open(fp, 'r', errors='ignore') as f:
                lines = f.readlines()
            
            if line_num > len(lines) or line_num < 1:
                return False, "Line out of range"
            
            # Get extended context
            start = max(0, line_num - 30)
            end = min(len(lines), line_num + 30)
            context = ''.join(lines[start:end])
            vulnerable_line = lines[line_num - 1]
            
            # User input indicators
            user_input_patterns = [
                r'request\.(get|post|args|form|json|data|cookies|headers)',
                r'input\s*=',
                r'form\[',
                r'query_params',
                r'\.get\(.*request',
                r'POST\[',
                r'GET\[',
                r'args\[',
                r'kwargs\[',
                r'body',
                r'params',
            ]
            
            has_user_input = any(re.search(pattern, context, re.IGNORECASE) for pattern in user_input_patterns)
            
            # CWE-specific checks
            if cwe == 'CWE-89':  # SQL Injection
                # Check if SQL uses user input
                if has_user_input and ('%' in vulnerable_line or 'f"' in vulnerable_line or '.format(' in vulnerable_line):
                    # Check if it's ORM (safe)
                    if any(x in context.lower() for x in ['.objects.', 'queryset', 'session.query', 'db.session']):
                        return False, "Uses ORM (safe)"
                    return True, "SQL injection with user input"
            
            elif cwe == 'CWE-78':  # Command Injection
                if has_user_input:
                    # Check for sanitization
                    if any(x in context.lower() for x in ['shlex.quote', 'escape', 'sanitize']):
                        return False, "Uses sanitization"
                    return True, "Command injection with user input"
            
            elif cwe == 'CWE-22':  # Path Traversal
                if has_user_input:
                    # Check for path validation
                    if any(x in context.lower() for x in ['abspath', 'realpath', 'normpath', 'validate']):
                        # Might still be exploitable if validation is weak
                        return True, "Path traversal with user input (needs validation check)"
                    return True, "Path traversal with user input"
            
            elif cwe == 'CWE-79':  # XSS
                # Check if in template/view
                if 'template' in file_path.lower() or 'view' in file_path.lower() or 'jinja' in file_path.lower():
                    if has_user_input:
                        # Check if escaping is disabled
                        if any(x in context.lower() for x in ['|safe', 'mark_safe', 'autoescape false']):
                            return True, "XSS with escaping disabled"
                        # Check if no escaping
                        if 'escape' not in context.lower() and 'autoescape' not in context.lower():
                            return True, "XSS without escaping"
            
            elif cwe == 'CWE-502':  # Deserialization
                if has_user_input:
                    return True, "Deserialization from user input"
            
            elif cwe == 'CWE-918':  # SSRF
                if has_user_input:
                    return True, "SSRF with user input"
            
            elif cwe == 'CWE-352':  # CSRF
                if has_user_input:
                    return True, "CSRF vulnerability"
            
            elif cwe == 'CWE-434':  # File Upload
                if has_user_input:
                    return True, "Unrestricted file upload"
            
            # If has user input and is a security-relevant CWE, might be exploitable
            if has_user_input and cwe in ['CWE-89', 'CWE-78', 'CWE-22', 'CWE-79', 'CWE-502', 'CWE-918', 'CWE-352', 'CWE-434']:
                return True, f"{cwe} with user input - potentially exploitable"
            
            return False, "No user input detected"
            
        except Exception as e:
            return False, f"Error: {e}"
    
    def get_distinct_key(self, finding: Dict) -> str:
        """Generate a key for distinct vulnerability tracking"""
        file_path = finding.get('file_path', '')
        line_num = finding.get('line_number', 0)
        cwe = finding.get('cwe', '')
        
        # Normalize file path (remove /tmp paths)
        normalized_path = file_path
        for prefix in ['/tmp/valid8_bulk_scan/', '/tmp/valid8_200_scan/']:
            if normalized_path.startswith(prefix):
                normalized_path = normalized_path[len(prefix):]
                break
        
        # Create distinct key
        return f"{cwe}:{normalized_path}:{line_num}"
    
    def clone_repo(self, repo: Dict[str, str]) -> Optional[Path]:
        """Clone a repository"""
        repo_name = repo['name']
        repo_url = repo['url']
        target_dir = self.scan_dir / repo_name
        
        if target_dir.exists():
            return target_dir
        
        print(f"  Cloning {repo_name}...")
        try:
            subprocess.run(
                ['git', 'clone', '--depth', '1', repo_url, str(target_dir)],
                check=True,
                capture_output=True,
                timeout=300
            )
            return target_dir
        except Exception as e:
            return None
    
    def scan_codebases(self, target_count: int = 100):
        """Scan codebases until we find target_count distinct exploitable vulnerabilities"""
        # Load existing progress if available
        progress_file = Path("bulk_scan_100_exploitable.json")
        if progress_file.exists():
            with open(progress_file, 'r') as f:
                existing_data = json.load(f)
                self.verified_vulnerabilities = existing_data.get('verified_vulnerabilities', [])
                self.distinct_issues = set(existing_data.get('distinct_issues', []))
                self.scan_stats = existing_data.get('stats', self.scan_stats)
                # Filter out Rust files from existing
                self.verified_vulnerabilities = [v for v in self.verified_vulnerabilities 
                                                if not v.get('file_path', '').endswith('.rs')]
                # Rebuild distinct_issues set
                self.distinct_issues = {v.get('_distinct_key', '') for v in self.verified_vulnerabilities if v.get('_distinct_key')}
                print(f"âœ… Loaded existing progress: {len(self.verified_vulnerabilities)} verified vulnerabilities")
                print()
        
        # Get list of repos (prioritize web frameworks and user-input areas)
        repos = self._get_prioritized_repos()
        
        print("="*80)
        print(f"ðŸ” Bulk Scan for {target_count} Distinct Exploitable Vulnerabilities")
        print(f"Current Progress: {len(self.verified_vulnerabilities)}/{target_count}")
        print("="*80)
        print()
        
        for i, repo in enumerate(repos, 1):
            if len(self.verified_vulnerabilities) >= target_count:
                break
            
            print(f"[{i}/{len(repos)}] Scanning {repo['name']}...")
            
            # Clone repo
            repo_path = self.clone_repo(repo)
            if not repo_path:
                continue
            
            # Get target directories (user-input areas)
            target_dirs = self.get_target_directories(repo_path, repo['name'])
            
            if not target_dirs:
                print(f"  âš ï¸  No target directories found")
                continue
            
            # Scan each target directory
            for target_dir in target_dirs:
                if len(self.verified_vulnerabilities) >= target_count:
                    break
                
                try:
                    print(f"  Scanning: {target_dir.relative_to(repo_path) if repo_path in target_dir.parents else target_dir.name}")
                    results = self.scanner.scan(str(target_dir), mode="fast")
                    findings = results.get('vulnerabilities', [])
                    
                    self.scan_stats['total_findings'] += len(findings)
                    
                    # Verify each finding
                    for finding in findings:
                        if len(self.verified_vulnerabilities) >= target_count:
                            break
                        
                        # Get code context
                        vuln_code = finding.get('vulnerable_code', {})
                        code_context = vuln_code.get('context', '') or vuln_code.get('snippet', '') or ''
                        
                        # Check if exploitable (user input)
                        is_exploitable, reason = self.is_user_input_vulnerability(finding, code_context)
                        
                        if is_exploitable:
                            # Check if distinct
                            distinct_key = self.get_distinct_key(finding)
                            
                            if distinct_key not in self.distinct_issues:
                                self.distinct_issues.add(distinct_key)
                                finding['_verified'] = True
                                finding['_verification_reason'] = reason
                                finding['_repository'] = repo['name']
                                finding['_distinct_key'] = distinct_key
                                self.verified_vulnerabilities.append(finding)
                                
                                print(f"    âœ… Found exploitable: {finding.get('cwe')} - {finding.get('title')}")
                                print(f"       {Path(finding.get('file_path', '')).name}:{finding.get('line_number')}")
                        else:
                            self.scan_stats['filtered_noise'] += 1
                
                except Exception as e:
                    print(f"  âš ï¸  Error scanning {target_dir}: {e}")
            
            self.scan_stats['codebases_scanned'] += 1
            self.scan_stats['verified_exploitable'] = len(self.verified_vulnerabilities)
            self.scan_stats['distinct_issues'] = len(self.distinct_issues)
            
            print(f"  ðŸ“Š Progress: {len(self.distinct_issues)}/{target_count} distinct exploitable vulnerabilities")
            print()
            
            # Save progress
            self.save_progress()
        
        return self.verified_vulnerabilities
    
    def _get_prioritized_repos(self) -> List[Dict[str, str]]:
        """Get prioritized list of repositories (web frameworks first)"""
        repos = [
            # Web Frameworks (highest priority)
            {'name': 'django', 'url': 'https://github.com/django/django.git'},
            {'name': 'flask', 'url': 'https://github.com/pallets/flask.git'},
            {'name': 'fastapi', 'url': 'https://github.com/tiangolo/fastapi.git'},
            {'name': 'tornado', 'url': 'https://github.com/tornadoweb/tornado.git'},
            {'name': 'bottle', 'url': 'https://github.com/bottlepy/bottle.git'},
            {'name': 'cherrypy', 'url': 'https://github.com/cherrypy/cherrypy.git'},
            {'name': 'pyramid', 'url': 'https://github.com/Pylons/pyramid.git'},
            {'name': 'web2py', 'url': 'https://github.com/web2py/web2py.git'},
            {'name': 'sanic', 'url': 'https://github.com/sanic-org/sanic.git'},
            {'name': 'starlette', 'url': 'https://github.com/encode/starlette.git'},
            {'name': 'quart', 'url': 'https://github.com/pallets/quart.git'},
            {'name': 'hug', 'url': 'https://github.com/hugapi/hug.git'},
            {'name': 'falcon', 'url': 'https://github.com/falconry/falcon.git'},
            
            # HTTP Libraries (SSRF, header injection)
            {'name': 'requests', 'url': 'https://github.com/psf/requests.git'},
            {'name': 'httpx', 'url': 'https://github.com/encode/httpx.git'},
            {'name': 'aiohttp', 'url': 'https://github.com/aio-libs/aiohttp.git'},
            {'name': 'urllib3', 'url': 'https://github.com/urllib3/urllib3.git'},
            
            # ORMs (SQL injection)
            {'name': 'sqlalchemy', 'url': 'https://github.com/sqlalchemy/sqlalchemy.git'},
            {'name': 'peewee', 'url': 'https://github.com/coleifer/peewee.git'},
            {'name': 'tortoise-orm', 'url': 'https://github.com/tortoise/tortoise-orm.git'},
            
            # Auth Libraries
            {'name': 'python-social-auth', 'url': 'https://github.com/python-social-auth/social-core.git'},
            {'name': 'python-jose', 'url': 'https://github.com/mpdavis/python-jose.git'},
            {'name': 'authlib', 'url': 'https://github.com/lepture/authlib.git'},
            {'name': 'oauthlib', 'url': 'https://github.com/oauthlib/oauthlib.git'},
            
            # Template Engines (template injection, XSS)
            {'name': 'jinja2', 'url': 'https://github.com/pallets/jinja2.git'},
            {'name': 'mako', 'url': 'https://github.com/sqlalchemy/mako.git'},
            {'name': 'chameleon', 'url': 'https://github.com/malthe/chameleon.git'},
            
            # Serialization (deserialization)
            {'name': 'marshmallow', 'url': 'https://github.com/marshmallow-code/marshmallow.git'},
            {'name': 'pydantic', 'url': 'https://github.com/pydantic/pydantic.git'},
            
            # File Processing (path traversal, file upload)
            {'name': 'openpyxl', 'url': 'https://github.com/theorchard/openpyxl.git'},
            {'name': 'python-docx', 'url': 'https://github.com/python-openxml/python-docx.git'},
            
            # More web frameworks and libraries
            {'name': 'dash', 'url': 'https://github.com/plotly/dash.git'},
            {'name': 'streamlit', 'url': 'https://github.com/streamlit/streamlit.git'},
            {'name': 'gradio', 'url': 'https://github.com/gradio-app/gradio.git'},
            {'name': 'chalice', 'url': 'https://github.com/aws/chalice.git'},
            {'name': 'zappa', 'url': 'https://github.com/Miserlou/Zappa.git'},
            
            # More HTTP libraries
            {'name': 'scrapy', 'url': 'https://github.com/scrapy/scrapy.git'},
            {'name': 'mechanize', 'url': 'https://github.com/python-mechanize/mechanize.git'},
            {'name': 'httpie', 'url': 'https://github.com/httpie/httpie.git'},
            
            # More ORMs
            {'name': 'pony', 'url': 'https://github.com/ponyorm/pony.git'},
            {'name': 'sqlobject', 'url': 'https://github.com/sqlobject/sqlobject.git'},
            
            # More auth
            {'name': 'flask-jwt-extended', 'url': 'https://github.com/vimalloc/flask-jwt-extended.git'},
            {'name': 'django-oauth-toolkit', 'url': 'https://github.com/jazzband/django-oauth-toolkit.git'},
            {'name': 'requests-oauthlib', 'url': 'https://github.com/requests/requests-oauthlib.git'},
            
            # More serialization
            {'name': 'cerberus', 'url': 'https://github.com/pyeve/cerberus.git'},
            {'name': 'schematics', 'url': 'https://github.com/schematics/schematics.git'},
            {'name': 'jsonschema', 'url': 'https://github.com/python-jsonschema/jsonschema.git'},
            
            # Database drivers
            {'name': 'pymongo', 'url': 'https://github.com/mongodb/mongo-python-driver.git'},
            {'name': 'redis-py', 'url': 'https://github.com/redis/redis-py.git'},
            {'name': 'psycopg2', 'url': 'https://github.com/psycopg/psycopg2.git'},
            {'name': 'pymysql', 'url': 'https://github.com/PyMySQL/PyMySQL.git'},
            
            # More file processing
            {'name': 'xlsxwriter', 'url': 'https://github.com/jmcnamara/XlsxWriter.git'},
            {'name': 'xlrd', 'url': 'https://github.com/python-excel/xlrd.git'},
            {'name': 'python-docx', 'url': 'https://github.com/python-openxml/python-docx.git'},
        ]
        
        return repos
    
    def save_progress(self):
        """Save scanning progress"""
        output_file = Path("bulk_scan_100_exploitable.json")
        
        data = {
            'stats': self.scan_stats,
            'verified_vulnerabilities': self.verified_vulnerabilities,
            'distinct_issues': list(self.distinct_issues),
            'total_verified': len(self.verified_vulnerabilities),
            'total_distinct': len(self.distinct_issues)
        }
        
        with open(output_file, 'w') as f:
            json.dump(data, f, indent=2)
    
    def generate_report(self):
        """Generate final report"""
        print("="*80)
        print("ðŸ“Š BULK SCAN COMPLETE")
        print("="*80)
        print()
        print(f"Codebases Scanned: {self.scan_stats['codebases_scanned']}")
        print(f"Total Findings: {self.scan_stats['total_findings']}")
        print(f"Filtered Noise: {self.scan_stats['filtered_noise']}")
        print(f"Verified Exploitable: {len(self.verified_vulnerabilities)}")
        print(f"Distinct Issues: {len(self.distinct_issues)}")
        print()
        
        # Group by CWE
        cwe_stats = defaultdict(int)
        for vuln in self.verified_vulnerabilities:
            cwe_stats[vuln.get('cwe', 'UNKNOWN')] += 1
        
        print("Findings by CWE:")
        for cwe, count in sorted(cwe_stats.items(), key=lambda x: x[1], reverse=True):
            print(f"  {cwe}: {count}")
        print()
        
        print(f"âœ… Results saved to: bulk_scan_100_exploitable.json")

def main():
    scanner = ExploitableVulnerabilityScanner()
    
    # Scan until we have 100 distinct exploitable vulnerabilities
    vulnerabilities = scanner.scan_codebases(target_count=100)
    
    # Generate report
    scanner.generate_report()
    
    print("="*80)
    print("âœ… SCANNING COMPLETE")
    print("="*80)
    print(f"Found {len(vulnerabilities)} verified exploitable vulnerabilities")
    print(f"Found {len(scanner.distinct_issues)} distinct issues")
    print()

if __name__ == '__main__':
    main()
